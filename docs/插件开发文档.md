# Noteva 插件开发文档

> 版本：v0.1.4-beta

## 快速开始

Noteva 插件系统允许你扩展博客功能，无需修改核心代码。

支持两种插件类型：
- **前端插件**：通过 JavaScript/CSS 在浏览器端运行，使用 Noteva SDK
- **WASM 后端插件**：通过 WebAssembly 在服务端沙盒中运行，可参与后端钩子处理

### 插件目录结构

```
plugins/
  my-plugin/
    plugin.json        # 插件配置（必需）
    frontend.js        # 前端脚本（可选）
    frontend.css       # 前端样式（可选）
    backend.wasm       # WASM 后端模块（可选）
    settings.json      # 设置项定义（可选）
    README.md          # 插件说明（可选）
```

---

## plugin.json 配置

```json
{
  "id": "my-plugin",
  "name": "我的插件",
  "version": "1.0.0",
  "description": "插件描述",
  "author": "Your Name",
  "license": "MIT",
  "requires": {
    "noteva": ">=0.1.3"
  },
  "hooks": {
    "frontend": ["content_render"],
    "backend": ["article_after_create", "plugin_activate", "plugin_action"]
  },
  "permissions": ["network", "storage", "read_articles"],
  "shortcodes": [],
  "settings": true
}
```

### 字段说明

| 字段 | 必需 | 说明 |
|-----|------|------|
| `id` | 是 | 插件唯一标识，小写字母和连字符，必须与目录名一致 |
| `name` | 是 | 插件显示名称 |
| `version` | 是 | 版本号（语义化版本） |
| `description` | | 插件描述 |
| `author` | | 作者 |
| `license` | | 开源协议 |
| `requires.noteva` | | 最低版本要求，如 `>=0.1.3` |
| `hooks.frontend` | | 前端钩子列表 |
| `hooks.backend` | | 后端钩子列表（需要 backend.wasm） |
| `permissions` | | WASM 插件所需权限列表 |
| `shortcodes` | | 注册的短代码列表 |
| `settings` | | 是否有设置项（true/false） |

### 可用权限

| 权限 | 说明 |
|-----|------|
| `network` | 发起 HTTP 请求（调用外部 API） |
| `storage` | 插件数据存储（key-value，按插件 ID 隔离） |
| `read_articles` | 查询文章列表（用于批量处理等场景） |
| `read_comments` | 读取评论数据 |
| `write_articles` | 修改文章数据 |
| `write_comments` | 修改评论数据 |
| `read_config` | 读取系统配置 |
| `write_config` | 修改系统配置 |
| `fs_read` | 读取文件系统 |
| `fs_write` | 写入文件系统 |

> `storage` 权限会自动授予所有 WASM 插件，但建议显式声明以保持清晰。

---

## settings.json 配置

定义插件的可配置项，后台会自动生成设置界面。

```json
{
  "sections": [
    {
      "id": "api",
      "title": "API 配置",
      "fields": [
        {
          "id": "api_url",
          "type": "text",
          "label": "API 地址",
          "default": "https://api.example.com",
          "placeholder": "https://..."
        },
        {
          "id": "api_key",
          "type": "text",
          "label": "API Key",
          "default": "",
          "placeholder": "sk-...",
          "secret": true
        }
      ]
    },
    {
      "id": "display",
      "title": "显示设置",
      "fields": [
        {
          "id": "enabled",
          "type": "switch",
          "label": "启用功能",
          "default": true
        },
        {
          "id": "max_count",
          "type": "number",
          "label": "最大数量",
          "default": 10,
          "min": 1,
          "max": 100
        }
      ]
    }
  ]
}
```

### 支持的字段类型

| 类型 | 说明 | 额外属性 |
|-----|------|---------|
| `text` | 单行文本 | `placeholder`, `maxLength`, `secret` |
| `textarea` | 多行文本 | `rows` |
| `number` | 数字 | `min`, `max`, `step` |
| `switch` | 开关 | - |
| `select` | 下拉选择 | `options` |
| `color` | 颜色选择器 | - |
| `image` | 图片上传 | - |
| `array` | 数组/列表 | `itemFields` |

### secret 字段

在字段定义中添加 `"secret": true`，该字段的值不会出现在公开 API（`GET /plugins/enabled`）的响应中。适用于 API Key、密码等敏感信息。

- 公开 API：secret 字段被过滤，前端无法获取
- WASM 钩子：secret 字段正常注入（后端需要使用）
- Action API 响应：所有插件设置字段自动剥离

### array 类型

用于创建可视化的列表编辑器，支持添加、删除、排序。

```json
{
  "id": "links",
  "type": "array",
  "label": "友情链接",
  "default": [],
  "itemFields": [
    { "id": "name", "label": "名称", "type": "text", "required": true },
    { "id": "url", "label": "链接", "type": "text", "required": true },
    { "id": "avatar", "label": "头像", "type": "text" }
  ]
}
```

前端获取：`Noteva.plugins.getSettings('my-plugin').links` 直接是数组。

---

## 前端插件开发（frontend.js）

### 基本结构

```javascript
(function() {
  const PLUGIN_ID = 'my-plugin';

  function waitForNoteva(callback) {
    if (typeof Noteva !== 'undefined') callback();
    else setTimeout(function() { waitForNoteva(callback); }, 100);
  }

  waitForNoteva(function() {
    var settings = Noteva.plugins.getSettings(PLUGIN_ID);

    // 注意：getSettings 返回从数据库加载的设置
    // 如果用户从未保存过设置，返回空对象 {}
    // 检查开关类设置时，应使用 === false 而非 !value
    if (settings.enabled === false) return;

    // 插件逻辑...

    console.log('[Plugin] my-plugin loaded');
  });
})();
```

### 前端钩子

| 钩子名 | 类型 | 触发时机 | 参数 |
|-------|------|---------|------|
| `article_view` | Action | 主题加载文章时 | `article` 完整文章对象 |
| `content_render` | Action | SPA 路由变化/DOM 变化时 | `{ path, query }` |
| `comment_after_create` | Action | 评论提交后 | `comment, { articleId }` |
| `body_end` | Action | 页面加载完成 | - |
| `seo_meta_tags` | Filter | SEO 元标签生成时 | `{ title, description, keywords }` |
| `admin_menu` | Filter | 管理后台菜单渲染时 | `{ items }` |
| `admin_dashboard` | Filter | 管理后台仪表盘渲染时 | `{ widgets }` |
| `nav_items_filter` | Filter | 导航菜单渲染时 | `{ items }` |

```javascript
// 文章查看（最常用，可获取文章 ID）
Noteva.hooks.on('article_view', function(article) {
  // article: { id, slug, title, content, content_html, ... }
  console.log('Viewing article:', article.id, article.title);
});

// 内容渲染（SPA 导航时自动触发）
Noteva.hooks.on('content_render', function(context) {
  // context: { path, query }
});

// 页面加载完成
Noteva.ready(function() {
  // 初始化
});
```

### 路由匹配

```javascript
var match = Noteva.router.match('/posts/:slug');
if (match.matched) {
  var slug = match.params.slug;
  // 当前在文章页
}
```

### 插件数据 API（公开）

读取后端 WASM 插件存储的数据，无需登录：

```javascript
// SDK 方式
var value = await Noteva.plugins.getData('my-plugin', 'some-key');

// 或直接 fetch
fetch('/api/v1/plugins/my-plugin/data/some-key')
  .then(function(r) { return r.json(); })
  .then(function(d) { console.log(d.value); });
```

### 插件 Action API（需管理员登录）

触发插件的自定义后端操作：

```javascript
fetch('/api/v1/admin/plugins/my-plugin/action/regenerate', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  credentials: 'include',
  body: JSON.stringify({ article_id: 123 })
})
  .then(function(r) { return r.json(); })
  .then(function(d) {
    // d: { success: true, data: { ... } }
  });
```

> Action API 在 `/admin/` 路径下，受 `require_admin` + `require_auth` 中间件保护。

### 插件注入点（PluginSlot）

主题中预留了多个注入点：

| 注入点 | 位置 |
|-------|------|
| `body_start` | 页面顶部 |
| `body_end` | 页面底部 |
| `article_content_top` | 文章内容顶部 |
| `article_content_bottom` | 文章内容底部 |
| `article_after_content` | 文章卡片下方 |
| `comment_form_before` | 评论表单上方 |
| `comment_form_after` | 评论表单下方 |

```javascript
// 方式一：SDK slots（静态 HTML）
Noteva.slots.register('article_content_top', '<div>内容</div>', 10);

// 方式二：DOM 操作（动态内容）
var slot = document.querySelector('[data-noteva-slot="article_content_top"]');
if (slot) slot.appendChild(myElement);
```

### 用户状态

```javascript
var user = await Noteva.user.check();
if (Noteva.user.isLoggedIn()) {
  var current = Noteva.user.getCurrent();
  // { id, username, email, avatar, role }
  if (current.role === 'admin') {
    // 管理员专属功能
  }
}
```

### UI 工具

```javascript
Noteva.ui.toast('操作成功', 'success');
Noteva.ui.toast('操作失败', 'error');
var confirmed = await Noteva.ui.confirm('确定要执行吗？');
```

### 暗色模式适配

主题使用 class-based 暗色模式（`<html class="dark">`），CSS 应使用 `.dark` 选择器：

```css
.my-plugin-box {
  background: #f0f9ff;
  color: #334155;
}

.dark .my-plugin-box {
  background: #0f172a;
  color: #cbd5e1;
}
```

> 不要使用 `@media (prefers-color-scheme: dark)`，它不会跟随主题切换。

---

## WASM 后端插件开发

WASM 后端插件在服务端沙盒中运行，通过子进程隔离（wasm-worker），插件崩溃不会影响主程序。

### 架构

```
主程序 (noteva)
  |
  +-- 钩子触发 -> 生成 JSON 输入（自动注入插件设置）
  |
  +-- 启动子进程 (wasm-worker)
  |     +-- 加载 backend.wasm
  |     +-- 注册宿主函数（网络、存储、日志、文章查询）
  |     +-- 调用 hook_xxx(ptr, len) -> result_ptr
  |     +-- 返回 JSON 结果 + 存储操作列表
  |
  +-- 执行存储操作 -> 写入数据库
```

关键特性：
- 插件设置自动注入到钩子输入数据中，无需手动读取配置
- 存储操作在子进程结束后由主程序批量执行，保证数据一致性
- 每次钩子调用都是独立的子进程，无状态
- 插件崩溃（panic、内存越界等）只影响子进程，主程序不受影响

### 编译

推荐使用 `wasm32-wasip1` 目标（支持标准库）：

```bash
# 安装编译目标（一次性）
rustup target add wasm32-wasip1

# 编译
cargo build --release --target wasm32-wasip1

# 复制到插件目录
cp target/wasm32-wasip1/release/my_plugin.wasm plugins/my-plugin/backend.wasm
```

Cargo.toml：

```toml
[package]
name = "my-plugin"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[profile.release]
opt-level = "s"
lto = true
strip = true
```

> 不需要任何外部依赖。宿主函数通过 `extern "C"` 声明，JSON 手动解析即可。

### 宿主函数

所有宿主函数在 `"env"` 模块下注册，WASM 插件通过 `extern "C"` 声明使用。

**所有宿主函数都必须声明**，即使不使用。WASM 模块在编译时声明所有导入，实例化时如果缺少任何一个都会失败。权限检查在函数体内部进行——无权限时返回 0 或空结果，不会导致 trap。

```rust
extern "C" {
    // 日志输出（无需权限）
    fn host_log(level_ptr: i32, level_len: i32, msg_ptr: i32, msg_len: i32);

    // HTTP 请求（需要 network 权限）
    fn host_http_request(
        method_ptr: i32, method_len: i32,
        url_ptr: i32, url_len: i32,
        headers_ptr: i32, headers_len: i32,
        body_ptr: i32, body_len: i32,
    ) -> i32;

    // 存储操作（需要 storage 权限，自动授予）
    fn host_storage_get(key_ptr: i32, key_len: i32) -> i32;
    fn host_storage_set(key_ptr: i32, key_len: i32, value_ptr: i32, value_len: i32) -> i32;
    fn host_storage_delete(key_ptr: i32, key_len: i32) -> i32;

    // 文章查询（需要 read_articles 权限）
    fn host_query_articles(filter_ptr: i32, filter_len: i32) -> i32;
    fn host_get_article(id_ptr: i32, id_len: i32) -> i32;

    // 评论查询（需要 read_comments 权限）
    fn host_get_comments(article_id_ptr: i32, article_id_len: i32) -> i32;

    // 文章元数据更新（需要 write_articles 权限）
    fn host_update_article_meta(article_id: i32, data_ptr: i32, data_len: i32) -> i32;
}
```

#### host_log

输出日志到主服务器。level 支持 `"info"`, `"warn"`, `"error"`。

```rust
fn log(level: &str, msg: &str) {
    unsafe {
        host_log(
            level.as_ptr() as i32, level.len() as i32,
            msg.as_ptr() as i32, msg.len() as i32,
        );
    }
}

// 使用
log("info", "Processing article...");
```

日志输出格式：`[wasm:plugin-id][level] message`

#### host_http_request

发起 HTTP 请求。支持 GET/POST/PUT/DELETE/PATCH。

- 超时：10 秒
- 响应体限制：1 MB
- 返回值：指向响应 JSON 的内存指针（4 字节长度前缀 + JSON 字节）
- 返回 0 表示失败

响应 JSON 格式：`{"status": 200, "body": "响应内容"}`

```rust
fn http_post(url: &str, headers: &str, body: &[u8]) -> Option<String> {
    let method = "POST";
    let result_ptr = unsafe {
        host_http_request(
            method.as_ptr() as i32, method.len() as i32,
            url.as_ptr() as i32, url.len() as i32,
            headers.as_ptr() as i32, headers.len() as i32,
            body.as_ptr() as i32, body.len() as i32,
        )
    };
    if result_ptr <= 0 { return None; }
    read_result(result_ptr) // 读取 4 字节长度前缀 + JSON
}
```

#### host_storage_get / set / delete

插件数据存储，按插件 ID 自动隔离。

- `get`：返回 JSON `{"found": true, "value": "..."}` 或 `{"found": false, "value": ""}`
- `set`：返回 > 0 表示成功
- `delete`：返回 > 0 表示成功

```rust
fn storage_get(key: &str) -> Option<String> {
    let result_ptr = unsafe {
        host_storage_get(key.as_ptr() as i32, key.len() as i32)
    };
    if result_ptr <= 0 { return None; }
    let json = read_result(result_ptr)?;
    if !json.contains("\"found\":true") { return None; }
    extract_json_string(&json, "value")
}

fn storage_set(key: &str, value: &str) -> bool {
    unsafe {
        host_storage_set(
            key.as_ptr() as i32, key.len() as i32,
            value.as_ptr() as i32, value.len() as i32,
        ) > 0
    }
}

fn storage_delete(key: &str) -> bool {
    unsafe {
        host_storage_delete(key.as_ptr() as i32, key.len() as i32) > 0
    }
}
```

存储的数据可通过公开 API 读取：`GET /api/v1/plugins/{plugin_id}/data/{key}`

#### host_query_articles

查询所有已发布文章。返回 JSON 数组字符串。

```rust
fn query_articles() -> Option<String> {
    let filter = "{}";
    let result_ptr = unsafe {
        host_query_articles(filter.as_ptr() as i32, filter.len() as i32)
    };
    if result_ptr <= 0 { return None; }
    read_result(result_ptr)
}
// 返回: [{"id":1,"title":"...","slug":"...","content":"..."}, ...]
```

#### host_get_article

根据文章 ID 查询单篇文章。需要 `read_articles` 权限。返回单篇文章的 JSON 字符串，找不到时返回 `null`。

```rust
extern "C" {
    fn host_get_article(id_ptr: i32, id_len: i32) -> i32;
}

fn get_article(id: i64) -> Option<String> {
    let id_str = id.to_string();
    let result_ptr = unsafe {
        host_get_article(id_str.as_ptr() as i32, id_str.len() as i32)
    };
    if result_ptr <= 0 { return None; }
    read_result(result_ptr)
}
// 返回: {"id":1,"title":"...","slug":"...","content":"...","content_html":"..."}
// 找不到时返回: "null"
```

#### host_get_comments

查询指定文章的评论列表。需要 `read_comments` 权限。返回评论 JSON 数组字符串。

```rust
extern "C" {
    fn host_get_comments(article_id_ptr: i32, article_id_len: i32) -> i32;
}

fn get_comments(article_id: i64) -> Option<String> {
    let id_str = article_id.to_string();
    let result_ptr = unsafe {
        host_get_comments(id_str.as_ptr() as i32, id_str.len() as i32)
    };
    if result_ptr <= 0 { return None; }
    read_result(result_ptr)
}
// 返回: [{"id":1,"content":"...","author_name":"...","created_at":"..."}, ...]
```

> **权限说明**：`host_get_article` 需要在 `plugin.json` 中声明 `read_articles` 权限，`host_get_comments` 需要声明 `read_comments` 权限。

#### host_update_article_meta

更新文章的插件元数据。需要 `write_articles` 权限。数据会存储在文章的 `meta` JSON 字段中，按插件 ID 自动隔离命名空间。

```rust
extern "C" {
    fn host_update_article_meta(article_id: i32, data_ptr: i32, data_len: i32) -> i32;
}

fn update_article_meta(article_id: i64, data: &str) -> bool {
    unsafe {
        host_update_article_meta(
            article_id as i32,
            data.as_ptr() as i32,
            data.len() as i32,
        ) > 0
    }
}

// 示例：AI 摘要插件写入摘要
let summary_data = r#"{"summary":"这篇文章讲了...","generated_at":"2026-02-12"}"#;
update_article_meta(article_id, summary_data);
// 文章 meta 字段结果: {"ai-summary": {"summary":"这篇文章讲了...","generated_at":"2026-02-12"}}
```

> **命名空间隔离**：每个插件只能写入自己 `plugin_id` 对应的命名空间。例如 `ai-summary` 插件写入的数据会存储在 `meta["ai-summary"]` 下，不会影响其他插件的数据。文章 API 返回时会包含完整的 `meta` 字段。

### 自定义 API 路由

插件可以注册自定义的 HTTP API 端点。在 `plugin.json` 中声明 `"api": true`，并在 WASM 中导出 `handle_request` 函数。

#### plugin.json 配置

```json
{
  "id": "my-plugin",
  "api": true,
  ...
}
```

#### 路由格式

```
ANY /api/v1/plugins/{plugin_id}/api/{path}
```

例如：`GET /api/v1/plugins/ai-summary/api/status` 或 `POST /api/v1/plugins/my-plugin/api/webhook`

#### WASM 端实现

导出 `handle_request` 函数，接收请求 JSON，返回响应 JSON：

```rust
#[no_mangle]
pub extern "C" fn handle_request(ptr: i32, len: i32) -> i32 {
    // 输入 JSON: {"method":"GET","path":"status","body":""}
    let method = extract_json_string(input, "method").unwrap_or_default();
    let path = extract_json_string(input, "path").unwrap_or_default();
    let body = extract_json_string(input, "body").unwrap_or_default();

    // 处理请求...
    let response = match (method.as_str(), path.as_str()) {
        ("GET", "status") => r#"{"status":200,"body":"{\"ok\":true}"}"#,
        _ => r#"{"status":404,"body":"{\"error\":\"not found\"}"}"#,
    };

    write_response(response)
}
```

#### 响应格式

```json
{
  "status": 200,
  "content_type": "application/json",
  "body": "{\"ok\":true}"
}
```

- `status`：HTTP 状态码，默认 200
- `content_type`：响应类型，默认 `application/json`
- `body`：响应体字符串

> **注意**：自定义 API 路由是公开的，不需要认证。插件内部可通过 `host_storage` 实现简单的鉴权逻辑。每个请求会启动一个 wasm-worker 子进程执行，适合低频场景。

### 数据传递协议

主程序与 WASM 模块之间通过线性内存传递数据：

1. 主程序调用 `allocate(size)` 在 WASM 内存中分配缓冲区
2. 主程序将 JSON 输入写入缓冲区
3. 主程序调用 `hook_xxx(ptr, len)` 执行钩子
4. 钩子函数返回 result_ptr：
   - `0`：无输出（成功但无数据返回）
   - `> 0`：指向结果数据（前 4 字节为小端长度，后跟 JSON 字节）

必须导出的函数：

```rust
#[no_mangle]
pub extern "C" fn allocate(size: i32) -> i32 {
    if size <= 0 || size > 4 * 1024 * 1024 { return 0; }
    let layout = match Layout::from_size_align(size as usize, 1) {
        Ok(l) => l,
        Err(_) => return 0,
    };
    let ptr = unsafe { alloc(layout) };
    if ptr.is_null() { 0 } else { ptr as i32 }
}
```

读取宿主函数返回的结果：

```rust
fn read_result(ptr: i32) -> Option<String> {
    if ptr <= 0 { return None; }
    unsafe {
        let rp = ptr as usize;
        let len_bytes = slice::from_raw_parts(rp as *const u8, 4);
        let len = u32::from_le_bytes([len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]) as usize;
        if len == 0 || len > 2 * 1024 * 1024 { return None; }
        let data = slice::from_raw_parts((rp + 4) as *const u8, len);
        String::from_utf8(data.to_vec()).ok()
    }
}
```

写出钩子返回值：

```rust
fn write_output(json: &str) -> i32 {
    let bytes = json.as_bytes();
    let total = 4 + bytes.len();
    let layout = match Layout::from_size_align(total, 1) {
        Ok(l) => l,
        Err(_) => return 0,
    };
    let ptr = unsafe { alloc(layout) };
    if ptr.is_null() { return 0; }
    unsafe {
        let len_bytes = (bytes.len() as u32).to_le_bytes();
        std::ptr::copy_nonoverlapping(len_bytes.as_ptr(), ptr, 4);
        std::ptr::copy_nonoverlapping(bytes.as_ptr(), ptr.add(4), bytes.len());
    }
    ptr as i32
}
```

### 钩子输入数据

钩子函数接收的 JSON 输入包含两部分：
1. **钩子事件数据**：由触发点提供（如文章 ID、标题、内容等）
2. **插件设置**：自动注入，与后台设置界面中的值一致

例如 `article_after_create` 钩子收到的数据：

```json
{
  "id": 123,
  "title": "文章标题",
  "slug": "article-slug",
  "content": "文章内容...",
  "api_url": "https://api.example.com",
  "api_key": "sk-xxx",
  "model": "gpt-4o-mini",
  "max_count": 10
}
```

其中 `id`, `title`, `slug`, `content` 来自钩子事件，`api_url`, `api_key`, `model`, `max_count` 来自插件设置。

### 可用的后端钩子

> 钩子分为两种类型：**Filter**（过滤钩子）返回值会替换原始数据，链式传递给下一个处理函数；**Action**（动作钩子）返回值被忽略，仅用于副作用操作。

#### Article 钩子

| 钩子名 | 类型 | 触发时机 | 事件数据 | 超时 |
|-------|------|---------|---------|------|
| `article_before_create` | Filter | 文章创建前 | `{ title, slug, content, author_id, category_id, status }` | 5s |
| `article_after_create` | Action | 文章创建后 | `{ id, title, slug, content, author_id, category_id, status }` | 30s* |
| `article_before_update` | Filter | 文章更新前 | `{ id, title, content, slug, category_id, status }` | 5s |
| `article_after_update` | Action | 文章更新后 | `{ id, title, slug, content, author_id, category_id, status }` | 30s* |
| `article_before_delete` | Filter | 文章删除前 | `{ id, title }` | 5s |
| `article_after_delete` | Action | 文章删除后 | `{ id, success }` | 5s |
| `article_before_display` | Filter | 文章显示前 | `{ article, format }` | 5s |
| `article_view` | Action | 文章被查看时 | `{ id, slug, timestamp }` | 5s |
| `article_content_filter` | Filter | 文章内容过滤 | `{ content, article_id }` | 5s |
| `article_excerpt_filter` | Filter | 文章摘要过滤 | `{ excerpt, article_id }` | 5s |

#### Comment 钩子

| 钩子名 | 类型 | 触发时机 | 事件数据 | 超时 |
|-------|------|---------|---------|------|
| `comment_before_create` | Filter | 评论创建前 | `{ article_id, content, author_name, author_email }` | 5s |
| `comment_after_create` | Action | 评论创建后 | `{ id, article_id, content, author_name }` | 5s |
| `comment_before_delete` | Filter | 评论删除前 | `{ id }` | 5s |
| `comment_after_delete` | Action | 评论删除后 | `{ id, success }` | 5s |
| `comment_before_display` | Filter | 评论显示前 | `{ comments, count }` | 5s |
| `comment_content_filter` | Filter | 评论内容过滤 | `{ content, article_id }` | 5s |

#### User 钩子

| 钩子名 | 类型 | 触发时机 | 事件数据 | 超时 |
|-------|------|---------|---------|------|
| `user_login_before` | Filter | 用户登录前 | `{ username_or_email, timestamp }` | 5s |
| `user_login_after` | Action | 用户登录后 | `{ user_id, username, timestamp }` | 5s |
| `user_login_failed` | Action | 登录失败时 | `{ username_or_email, reason, timestamp }` | 5s |
| `user_logout` | Action | 用户登出时 | `{ session_id, timestamp }` | 5s |
| `user_register_before` | Filter | 用户注册前 | `{ username, email, timestamp }` | 5s |
| `user_register_after` | Action | 用户注册后 | `{ id, username, email, timestamp }` | 5s |

#### Content Processing 钩子

| 钩子名 | 类型 | 触发时机 | 事件数据 | 超时 |
|-------|------|---------|---------|------|
| `markdown_before_parse` | Filter | Markdown 解析前 | `{ content }` | 5s |
| `markdown_after_parse` | Action | Markdown 解析后 | `{ html }` | 5s |
| `excerpt_generate` | Filter | 摘要生成时 | `{ content, excerpt }` | 5s |

#### System 钩子

| 钩子名 | 类型 | 触发时机 | 事件数据 | 超时 |
|-------|------|---------|---------|------|
| `system_init` | Action | 系统初始化完成 | `{ version, timestamp }` | 5s |
| `cache_clear` | Action | 缓存清除时 | `{ scope, timestamp }` | 5s |
| `theme_switch` | Action | 主题切换时 | `{ old_theme, new_theme, timestamp }` | 5s |
| `api_request_before` | Filter | API 请求处理前 | `{ method, path, timestamp }` | 5s |
| `api_request_after` | Action | API 请求处理后 | `{ method, path, status, timestamp }` | 5s |

#### Plugin 钩子

| 钩子名 | 类型 | 触发时机 | 事件数据 | 超时 |
|-------|------|---------|---------|------|
| `plugin_activate` | Action | 插件启用时 | `{ plugin_id }` + 设置 | 300s |
| `plugin_deactivate` | Action | 插件禁用时 | `{ plugin_id }` | 5s |
| `plugin_destroy` | Action | 插件被禁用时（WASM 卸载前） | `{ plugin_id }` | 5s |
| `plugin_upgrade` | Action | 插件版本变更时 | `{ plugin_id, old_version, new_version }` | 5s |
| `plugin_action` | Action | 自定义操作 | `{ plugin_id, action, data }` + 设置 | 30s* |

> *带 `network` 权限的插件自动获得 30s 超时；`plugin_activate` 固定 300s（用于批量处理）。

#### 钩子校验

启用插件时，系统会自动校验 `plugin.json` 中声明的钩子：
- 检查钩子名称是否存在于注册表中
- 检查钩子的 scope 是否匹配（backend 钩子不能声明在 `hooks.frontend` 中，反之亦然）
- 校验不通过时记录警告日志，但不阻止插件加载（向前兼容）

### 系统钩子详解

#### plugin_activate

插件启用时触发，适合批量处理存量数据。例如 AI 摘要插件启用时为所有旧文章生成摘要。

```rust
#[no_mangle]
pub extern "C" fn hook_plugin_activate(ptr: i32, len: i32) -> i32 {
    // 解析输入...
    let plugin_id = extract_json_string(input, "plugin_id").unwrap_or_default();
    if plugin_id != "my-plugin" { return 0; } // 只处理自己

    // 查询所有文章
    let articles = query_articles().unwrap_or_default();
    // 批量处理...
    0
}
```

#### plugin_action

通用的自定义操作入口。前端通过 `POST /admin/plugins/:id/action/:action` 触发。

```rust
#[no_mangle]
pub extern "C" fn hook_plugin_action(ptr: i32, len: i32) -> i32 {
    // 解析输入...
    let plugin_id = extract_json_string(input, "plugin_id").unwrap_or_default();
    if plugin_id != "my-plugin" { return 0; }

    let action = extract_json_string(input, "action").unwrap_or_default();
    match action.as_str() {
        "regenerate" => handle_regenerate(input),
        "cleanup" => handle_cleanup(input),
        _ => 0,
    }
}
```

#### article_after_delete

文章删除后触发，适合清理关联数据：

```rust
#[no_mangle]
pub extern "C" fn hook_article_after_delete(ptr: i32, len: i32) -> i32 {
    // 解析输入获取 article id...
    let article_id = extract_json_number(input, "id").unwrap_or(0);
    // 清理存储的数据
    storage_delete(&format!("data:{}", article_id));
    0
}
```

#### plugin_destroy

插件被禁用时触发（在 WASM 模块卸载之前），适合清理资源。即使钩子执行失败，插件禁用流程也会继续完成。

```rust
#[no_mangle]
pub extern "C" fn hook_plugin_destroy(ptr: i32, len: i32) -> i32 {
    // 解析输入...
    let plugin_id = extract_json_string(input, "plugin_id").unwrap_or_default();
    if plugin_id != "my-plugin" { return 0; }

    // 清理临时数据、关闭连接等
    storage_delete("temp_cache");
    log("info", "Plugin resources cleaned up");
    0
}
```

#### plugin_upgrade

插件版本变更时触发（启用插件时检测到 plugin.json 版本与上次记录不同），适合数据迁移。即使钩子执行失败，插件启用流程也会继续完成。

```rust
#[no_mangle]
pub extern "C" fn hook_plugin_upgrade(ptr: i32, len: i32) -> i32 {
    // 解析输入...
    let plugin_id = extract_json_string(input, "plugin_id").unwrap_or_default();
    if plugin_id != "my-plugin" { return 0; }

    let old_version = extract_json_string(input, "old_version").unwrap_or_default();
    let new_version = extract_json_string(input, "new_version").unwrap_or_default();
    log("info", &format!("Upgrading from {} to {}", old_version, new_version));

    // 执行数据迁移逻辑...
    0
}
```

### 沙盒安全机制

| 限制项 | 默认值 | 说明 |
|-------|-------|------|
| 内存限制 | 16 MB | 防止内存泄漏 |
| 指令限制 | 1 亿条（fuel） | 防止死循环 |
| 执行超时 | 5s / 30s / 300s | 根据钩子类型自动调整 |
| 权限控制 | 白名单 | 只能使用 plugin.json 中声明的权限 |
| 进程隔离 | 子进程 | 每次调用独立子进程，崩溃不影响主程序 |
| HTTP 超时 | 10s | 单次 HTTP 请求超时 |
| HTTP 响应限制 | 1 MB | 响应体大小限制 |

### JSON 解析工具

由于 WASM 插件不引入外部依赖，需要手动解析 JSON。以下是常用的工具函数：

```rust
/// 从 JSON 中提取字符串值（支持 UTF-8 和 \uXXXX 转义）
fn extract_json_string(json: &str, key: &str) -> Option<String> {
    let pattern = format!("\"{}\":", key);
    let start = json.find(&pattern)? + pattern.len();
    let rest = json[start..].trim_start();
    if !rest.starts_with('"') { return None; }
    let rest = &rest[1..];

    let mut result = Vec::new();
    let bytes = rest.as_bytes();
    let mut i = 0;
    while i < bytes.len() {
        if bytes[i] == b'"' { break; }
        if bytes[i] == b'\\' && i + 1 < bytes.len() {
            i += 1;
            match bytes[i] {
                b'n' => result.push(b'\n'),
                b't' => result.push(b'\t'),
                b'r' => result.push(b'\r'),
                b'"' => result.push(b'"'),
                b'\\' => result.push(b'\\'),
                b'/' => result.push(b'/'),
                b'u' if i + 4 < bytes.len() => {
                    // \uXXXX unicode 转义处理
                    // ... 完整实现见 ai-summary 插件源码
                    i += 4;
                    continue;
                }
                other => { result.push(b'\\'); result.push(other); }
            }
        } else {
            result.push(bytes[i]);
        }
        i += 1;
    }
    String::from_utf8(result).ok()
}

/// 从 JSON 中提取数字值
fn extract_json_number(json: &str, key: &str) -> Option<i64> {
    let pattern = format!("\"{}\":", key);
    let start = json.find(&pattern)? + pattern.len();
    let rest = json[start..].trim_start();
    let end = rest.find(|c: char| !c.is_ascii_digit() && c != '-')?;
    rest[..end].parse().ok()
}

/// JSON 字符串转义
fn escape_json_string(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    for c in s.chars() {
        match c {
            '"' => out.push_str("\\\""),
            '\\' => out.push_str("\\\\"),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            c if (c as u32) < 0x20 => {
                out.push_str(&format!("\\u{:04x}", c as u32));
            }
            c => out.push(c),
        }
    }
    out
}
```

> 完整的 JSON 工具函数实现可参考 `plugins/ai-summary/wasm-src/src/lib.rs`。

### UTF-8 注意事项

处理中文等多字节字符时需要注意：
- 字符串截断必须在字符边界：使用 `is_char_boundary()` 检查
- 不要用 `b as char` 转换字节为字符，应收集字节后用 `String::from_utf8()`
- JSON 中的 `\uXXXX` 转义需要处理 surrogate pair（`\uD800-\uDFFF`）

```rust
// 安全截断 UTF-8 字符串
let truncated = if content.len() > max_len {
    let mut end = max_len;
    while end > 0 && !content.is_char_boundary(end) {
        end -= 1;
    }
    &content[..end]
} else {
    content
};
```

---

## API 参考

### 公开 API（无需登录）

| 方法 | 路径 | 说明 |
|-----|------|------|
| GET | `/api/v1/plugins/assets/plugins.js` | 所有启用插件的合并 JS |
| GET | `/api/v1/plugins/assets/plugins.css` | 所有启用插件的合并 CSS |
| GET | `/api/v1/plugins/enabled` | 启用的插件列表及设置（secret 字段已过滤） |
| GET | `/api/v1/plugins/:id/data/:key` | 读取插件存储数据 |

### 管理 API（需要管理员登录）

| 方法 | 路径 | 说明 |
|-----|------|------|
| GET | `/api/v1/admin/plugins` | 插件列表 |
| GET | `/api/v1/admin/plugins/:id` | 插件详情 |
| POST | `/api/v1/admin/plugins/:id/toggle` | 启用/禁用插件 |
| GET | `/api/v1/admin/plugins/:id/settings` | 获取插件设置 |
| POST | `/api/v1/admin/plugins/:id/settings` | 更新插件设置 |
| GET | `/api/v1/admin/plugins/:id/data/:key` | 读取插件数据 |
| PUT | `/api/v1/admin/plugins/:id/data/:key` | 写入插件数据 |
| DELETE | `/api/v1/admin/plugins/:id/data/:key` | 删除插件数据 |
| POST | `/api/v1/admin/plugins/:id/action/:action` | 触发插件自定义操作 |
| GET | `/api/v1/admin/plugins/wasm/status` | WASM 运行时状态 |

---

## 调试技巧

1. 浏览器控制台查看 `[Plugin] xxx loaded` 确认前端加载
2. 服务端日志查看 `[wasm:plugin-id]` 前缀的 WASM 插件日志
3. 使用 `host_log("info", "debug message")` 在 WASM 中输出调试信息
4. 检查 `/api/v1/plugins/enabled` 确认插件设置是否正确加载
5. 检查 `/api/v1/plugins/:id/data/:key` 确认存储数据是否正确写入
6. 编译后确保 `backend.wasm` 已复制到插件目录
7. debug 和 release 模式的 `wasm-worker` 是独立的，修改后两个都需要重新编译

### 常见问题

**Q: WASM 插件加载失败，报 `unknown import: wasi_snapshot_preview1::fd_write`**
A: 使用 `wasm32-wasip1` 编译的模块需要 WASI 支持。确保 Noteva 版本 >= 0.1.3-beta，该版本已内置 WASI stubs。

**Q: 插件设置在前端获取为空对象**
A: 用户未在后台保存过设置时，`getSettings()` 返回 `{}`。检查开关类设置应使用 `=== false` 而非 `!value`。

**Q: 存储数据 API 返回 HTML 而非 JSON**
A: 确认请求路径正确（`/api/v1/plugins/:id/data/:key`），检查 Content-Type 响应头。

**Q: cargo build 后 wasm-worker 没更新**
A: cargo 增量编译可能跳过链接。删除旧的 exe 文件后重新编译，或 touch 源文件强制重编译。
